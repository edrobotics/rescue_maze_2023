Make a function to calculate the difference between any angles - can replace some code present now.

gyroTurn() - can turn more than 180 degrees. Divide it into < 180 degree segments.

General - add some way of filtering out unreasonable results and falling back to "dumb" methods in those cases.

General - if I call the MeUltrasonicSensor::distanceCm() too rapidly, will the distances update every time?

The method to check for wall changes will have to be updated - right now it will fail if a sensor mistakenly measures so wrong that the wallPresence changes.
    Maybe calculate some kind of average and round it to 1 or 0? (so that a temporary error won't destroy everything)

Design of driveStep(): Should the checks modify trueDistanceDriven or should they just break and then the program will decide outside of the loop whether the distance has been drive or not?

Note: I modified the source code of MeUltrasonicSensor.cpp to be able to specify the maximum distance measurement

Note: The last thing that worked alright (?) was not checking the back sensors for wallchanges. The problem with interference did appear (even though it should have).

Check colour sensor (and others) in getUltrasonics.

Instead of moving every measurement in the array, keep the current index and just change that value. Could also calculate the average more efficiently.

Calculation of the current angle for use in the next angle should be separated out into its own function.

How and when is g_gyroOffset updated?

Add a requirement that trueDistanceDriven is close enough to what it will be corrected to when a wallchange is detected

When driving backwards, the detected wallchanges will be wrong. To do correctly, make an expression taking the target distance into account (or the starting distance, or maybe just special case for driving backwards)



Bugs:

Sometimes when the robot is close to a wall, it drives slowly forward and sometimes does not recognise the wall. (potentially fixed?)

Sometimes when the robot is driving without walls and you correct it (maybe something else is triggering it), it drives in a circle and does not drive backwards when it is stopped.
The trueDistanceDriven seems to be wrong (oscillates because the robot is driving in a circle)
Why is the robot not correcting accordingly with the data? The angles must be wrong (is this the same issue as the bug below?)

When the robot is going backwards, something seems to go wrong with the angles (it makes a "three point turn" but with an arbitrary amount of points and the oscillation gets larger every time)

Sometimes the robot does not correct the right amount when turning.

Sometimes (often?) when a backwallchange should be detected it is not and the frontwallchange is used instead.

The robot does not seem to stop directly when detecting a new ground colour - instead it looks like it always drives the 30cm it should. Why is that?
Should have been fixed. Was probably caused by an inverted return statement (but I have NOT tested if it works now!)


Other (not necessarily bugs, but things to fix):
In driveStep(), when the first measurements are taken, the robot only uses one wall even if both are present.


After you have stopped, flush the distance arrays and update the robotAngle somehow. This should also be done before and after turning.

The driveStepDriveLoop takes too much time. How can I improve it?
    Make the getUltrasonics() function take less time
    Perhaps not calculate the angle every time (how much time does it take?)- just the difference? Then calculate the angle only when needed (say when you left the wall you calculate the angle based on the previous data. also in the end)